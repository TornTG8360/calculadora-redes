{"ast":null,"code":"var _jsxFileName = \"/workspaces/calculadora-redes/calculadora-ip/src/calculadora.js\",\n  _s = $RefreshSig$();\nimport React from \"react\";\nimport \"./styles.css\";\nimport InputIP from \"./InputIP\";\nimport InputMascara from \"./InputMascara\";\nimport ResultadosIP from \"./ResultadosIP\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Calculadora() {\n  _s();\n  let [inputIP, setInputIP] = React.useState(\"\");\n  let [inputMascara, setInputMascara] = React.useState(\"\");\n  let [resultado, setResultado] = React.useState(null);\n\n  // Las funciones de comprobación ahora están en los componentes hijos\n\n  function obtenerClaseIP(primerOcteto) {\n    if (primerOcteto >= 1 && primerOcteto <= 126) return \"A\";\n    if (primerOcteto >= 128 && primerOcteto <= 191) return \"B\";\n    if (primerOcteto >= 192 && primerOcteto <= 223) return \"C\";\n    if (primerOcteto >= 224 && primerOcteto <= 239) return \"D\";\n    if (primerOcteto >= 240 && primerOcteto <= 255) return \"E\";\n    return \"No válida\";\n  }\n  function convertirOctetosABinario(octetos) {\n    // Convertir cada octeto a su representación binaria\n    let binarios = octetos.map(octeto => {\n      // Convertir a número y obtener representación binaria\n      let bin = parseInt(octeto).toString(2);\n      // Rellenar con ceros a la izquierda hasta tener 8 bits\n      return bin.padStart(8, '0');\n    });\n\n    // Unir todos los octetos en una sola cadena binaria\n    return binarios.join('');\n  }\n  function convertirBinarioADecimal(binario) {\n    const octetos = [];\n    // Separar la cadena binaria en grupos de 8 bits\n    for (let i = 0; i < 32; i += 8) {\n      const octeto = parseInt(binario.substr(i, 8), 2);\n      octetos.push(octeto);\n    }\n    return octetos.join('.');\n  }\n  function esIPPrivada(ip) {\n    const octetos = ip.split('.');\n    if (octetos.length !== 4) return false;\n    const primerOcteto = parseInt(octetos[0]);\n    const segundoOcteto = parseInt(octetos[1]);\n\n    // Clase A: 10.0.0.0 - 10.255.255.255\n    if (primerOcteto === 10) {\n      return true;\n    }\n\n    // Clase B: 172.16.0.0 - 172.31.255.255\n    if (primerOcteto === 172 && segundoOcteto >= 16 && segundoOcteto <= 31) {\n      return true;\n    }\n\n    // Clase C: 192.168.0.0 - 192.168.255.255\n    if (primerOcteto === 192 && segundoOcteto === 168) {\n      return true;\n    }\n\n    // Link-local: 169.254.0.0 - 169.254.255.255\n    if (primerOcteto === 169 && segundoOcteto === 254) {\n      return true;\n    }\n\n    // Loopback: 127.0.0.0 - 127.255.255.255\n    if (primerOcteto === 127) {\n      return true;\n    }\n    return false;\n  }\n  function visualizarRedBinaria(ipBinario, mascaraBinaria) {\n    const ip = ipBinario.slice(0, 32);\n    const mascara = mascaraBinaria.slice(0, 32);\n    const octetos = ip.match(/.{8}/g);\n\n    // Encontrar la posición donde comienza la parte de host\n    const posicionHost = mascara.indexOf('0');\n    return {\n      ipCompleta: octetos.map((octeto, index) => {\n        // Calcular la posición inicial de este octeto en bits\n        const posInicial = index * 8;\n        const posFinal = posInicial + 8;\n\n        // Si este octeto contiene la transición de red a host\n        if (posicionHost >= posInicial && posicionHost < posFinal) {\n          const splitPos = posicionHost % 8;\n          return /*#__PURE__*/_jsxDEV(\"span\", {\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"red-portion\",\n              children: octeto.substring(0, splitPos)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 106,\n              columnNumber: 29\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"host-portion\",\n              children: octeto.substring(splitPos)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 107,\n              columnNumber: 29\n            }, this)]\n          }, index, true, {\n            fileName: _jsxFileName,\n            lineNumber: 105,\n            columnNumber: 25\n          }, this);\n        }\n        // Si el octeto está completamente en la porción de red\n        else if (posInicial < posicionHost) {\n          return /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"red-portion\",\n            children: octeto\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 113,\n            columnNumber: 28\n          }, this);\n        }\n        // Si el octeto está completamente en la porción de host\n        else {\n          return /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"host-portion\",\n            children: octeto\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 117,\n            columnNumber: 28\n          }, this);\n        }\n      })\n    };\n  }\n  function calcular() {\n    let partesIP = inputIP.split(\".\");\n    let partesMascara = inputMascara.split(\".\");\n\n    // Validar que cada octeto esté en el rango correcto\n    for (let i = 0; i < partesIP.length; i++) {\n      const octeto = parseInt(partesIP[i]);\n\n      // Verificar que sea un número válido y esté en el rango 0-255\n      if (isNaN(octeto) || octeto < 0 || octeto > 255) {\n        alert(`El octeto ${i + 1} de la IP no es válido. Debe ser un número entre 0 y 255.`);\n        return;\n      }\n\n      // Verificar que no haya números con ceros a la izquierda (excepto el 0)\n      if (partesIP[i].length > 1 && partesIP[i][0] === '0') {\n        alert(`El octeto ${i + 1} de la IP no puede tener ceros a la izquierda.`);\n        return;\n      }\n    }\n    for (let i = 0; i < partesMascara.length; i++) {\n      const octeto = parseInt(partesMascara[i]);\n\n      // Verificar que sea un número válido y esté en el rango 0-255\n      if (isNaN(octeto) || octeto < 0 || octeto > 255) {\n        alert(`El octeto ${i + 1} de la máscara no es válido. Debe ser un número entre 0 y 255.`);\n        return;\n      }\n\n      // Verificar que no haya números con ceros a la izquierda (excepto el 0)\n      if (partesMascara[i].length > 1 && partesMascara[i][0] === '0') {\n        alert(`El octeto ${i + 1} de la máscara no puede tener ceros a la izquierda.`);\n        return;\n      }\n    }\n    console.log(\"La dirección IP y la máscara son válidas\");\n    const ipBinario = convertirOctetosABinario(partesIP);\n    const mascaraBinario = convertirOctetosABinario(partesMascara);\n\n    // Realizar operaciones AND y OR a nivel de bits\n    let redBinaria = '';\n    let broadcastBinaria = '';\n    for (let i = 0; i < 32; i++) {\n      // Calcular dirección de red (AND)\n      redBinaria += ipBinario[i] === '1' && mascaraBinario[i] === '1' ? '1' : '0';\n\n      // Calcular broadcast (OR con NOT máscara)\n      broadcastBinaria += mascaraBinario[i] === '1' ? redBinaria[i] : '1';\n    }\n\n    // Convertir resultados a formato decimal\n    const ipRed = convertirBinarioADecimal(redBinaria);\n    const ipBroadcast = convertirBinarioADecimal(broadcastBinaria);\n\n    // Calcular primera y última IP útil\n    const primeraIPBinaria = redBinaria.slice(0, -1) + '1';\n    const ultimaIPBinaria = broadcastBinaria.slice(0, -1) + '0';\n    const primeraIP = convertirBinarioADecimal(primeraIPBinaria);\n    const ultimaIP = convertirBinarioADecimal(ultimaIPBinaria);\n\n    // Calcular hosts (utilizando la máscara)\n    const unosEnMascara = mascaraBinario.split('1').length - 1;\n    const hosts = Math.pow(2, 32 - unosEnMascara) - 2;\n    const representacionBinaria = visualizarRedBinaria(ipBinario, mascaraBinario);\n    setResultado({\n      ipRed,\n      ipBroadcast,\n      hosts,\n      rangoUtil: `${primeraIP} - ${ultimaIP}`,\n      clase: obtenerClaseIP(parseInt(partesIP[0])),\n      esPrivada: esIPPrivada(inputIP),\n      representacionBinaria: representacionBinaria\n    });\n  }\n  function limpiar() {\n    setInputIP(\"\");\n    setInputMascara(\"\");\n    setResultado(null);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"calculadora\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      className: \"titulo-principal\",\n      children: \"Calculadora de Direcciones IP\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 213,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"input-group\",\n      children: [/*#__PURE__*/_jsxDEV(InputIP, {\n        value: inputIP,\n        onChange: setInputIP\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 215,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(InputMascara, {\n        value: inputMascara,\n        onChange: setInputMascara\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 216,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: calcular,\n        children: \"Calcular\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 217,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: limpiar,\n        style: {\n          marginLeft: '10px'\n        },\n        children: \"Limpiar\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 218,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(ResultadosIP, {\n      resultado: resultado\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 220,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 212,\n    columnNumber: 9\n  }, this);\n}\n_s(Calculadora, \"BeAB1D5DZzq1jvONVPoZoyV8be4=\");\n_c = Calculadora;\nexport default Calculadora;\nvar _c;\n$RefreshReg$(_c, \"Calculadora\");","map":{"version":3,"names":["React","InputIP","InputMascara","ResultadosIP","jsxDEV","_jsxDEV","Calculadora","_s","inputIP","setInputIP","useState","inputMascara","setInputMascara","resultado","setResultado","obtenerClaseIP","primerOcteto","convertirOctetosABinario","octetos","binarios","map","octeto","bin","parseInt","toString","padStart","join","convertirBinarioADecimal","binario","i","substr","push","esIPPrivada","ip","split","length","segundoOcteto","visualizarRedBinaria","ipBinario","mascaraBinaria","slice","mascara","match","posicionHost","indexOf","ipCompleta","index","posInicial","posFinal","splitPos","children","className","substring","fileName","_jsxFileName","lineNumber","columnNumber","calcular","partesIP","partesMascara","isNaN","alert","console","log","mascaraBinario","redBinaria","broadcastBinaria","ipRed","ipBroadcast","primeraIPBinaria","ultimaIPBinaria","primeraIP","ultimaIP","unosEnMascara","hosts","Math","pow","representacionBinaria","rangoUtil","clase","esPrivada","limpiar","value","onChange","onClick","style","marginLeft","_c","$RefreshReg$"],"sources":["/workspaces/calculadora-redes/calculadora-ip/src/calculadora.js"],"sourcesContent":["\r\nimport React from \"react\";\r\nimport \"./styles.css\";\r\nimport InputIP from \"./InputIP\";\r\nimport InputMascara from \"./InputMascara\";\r\nimport ResultadosIP from \"./ResultadosIP\";\r\n\r\nfunction Calculadora() {\r\n    let [inputIP, setInputIP] = React.useState(\"\");\r\n    let [inputMascara, setInputMascara] = React.useState(\"\");\r\n    let [resultado, setResultado] = React.useState(null);\r\n\r\n    // Las funciones de comprobación ahora están en los componentes hijos\r\n\r\n    function obtenerClaseIP(primerOcteto) {\r\n        if (primerOcteto >= 1 && primerOcteto <= 126) return \"A\";\r\n        if (primerOcteto >= 128 && primerOcteto <= 191) return \"B\";\r\n        if (primerOcteto >= 192 && primerOcteto <= 223) return \"C\";\r\n        if (primerOcteto >= 224 && primerOcteto <= 239) return \"D\";\r\n        if (primerOcteto >= 240 && primerOcteto <= 255) return \"E\";\r\n        return \"No válida\";\r\n    }\r\n\r\n    function convertirOctetosABinario(octetos) {\r\n        // Convertir cada octeto a su representación binaria\r\n        let binarios = octetos.map(octeto => {\r\n            // Convertir a número y obtener representación binaria\r\n            let bin = parseInt(octeto).toString(2);\r\n            // Rellenar con ceros a la izquierda hasta tener 8 bits\r\n            return bin.padStart(8, '0');\r\n        });\r\n        \r\n        // Unir todos los octetos en una sola cadena binaria\r\n        return binarios.join('');\r\n    }\r\n\r\n    function convertirBinarioADecimal(binario) {\r\n        const octetos = [];\r\n        // Separar la cadena binaria en grupos de 8 bits\r\n        for(let i = 0; i < 32; i += 8) {\r\n            const octeto = parseInt(binario.substr(i, 8), 2);\r\n            octetos.push(octeto);\r\n        }\r\n        return octetos.join('.');\r\n    }\r\n\r\n    function esIPPrivada(ip) {\r\n        const octetos = ip.split('.');\r\n        if (octetos.length !== 4) return false;\r\n\r\n        const primerOcteto = parseInt(octetos[0]);\r\n        const segundoOcteto = parseInt(octetos[1]);\r\n        \r\n        // Clase A: 10.0.0.0 - 10.255.255.255\r\n        if (primerOcteto === 10) {\r\n            return true;\r\n        }\r\n\r\n        // Clase B: 172.16.0.0 - 172.31.255.255\r\n        if (primerOcteto === 172 && \r\n            segundoOcteto >= 16 && \r\n            segundoOcteto <= 31) {\r\n            return true;\r\n        }\r\n\r\n        // Clase C: 192.168.0.0 - 192.168.255.255\r\n        if (primerOcteto === 192 && \r\n            segundoOcteto === 168) {\r\n            return true;\r\n        }\r\n\r\n        // Link-local: 169.254.0.0 - 169.254.255.255\r\n        if (primerOcteto === 169 && \r\n            segundoOcteto === 254) {\r\n            return true;\r\n        }\r\n\r\n        // Loopback: 127.0.0.0 - 127.255.255.255\r\n        if (primerOcteto === 127) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function visualizarRedBinaria(ipBinario, mascaraBinaria) {\r\n        const ip = ipBinario.slice(0, 32);\r\n        const mascara = mascaraBinaria.slice(0, 32);\r\n        \r\n        const octetos = ip.match(/.{8}/g);\r\n        \r\n        // Encontrar la posición donde comienza la parte de host\r\n        const posicionHost = mascara.indexOf('0');\r\n        \r\n        return {\r\n            ipCompleta: octetos.map((octeto, index) => {\r\n                // Calcular la posición inicial de este octeto en bits\r\n                const posInicial = index * 8;\r\n                const posFinal = posInicial + 8;\r\n                \r\n                // Si este octeto contiene la transición de red a host\r\n                if (posicionHost >= posInicial && posicionHost < posFinal) {\r\n                    const splitPos = posicionHost % 8;\r\n                    return (\r\n                        <span key={index}>\r\n                            <span className=\"red-portion\">{octeto.substring(0, splitPos)}</span>\r\n                            <span className=\"host-portion\">{octeto.substring(splitPos)}</span>\r\n                        </span>\r\n                    );\r\n                }\r\n                // Si el octeto está completamente en la porción de red\r\n                else if (posInicial < posicionHost) {\r\n                    return <span key={index} className=\"red-portion\">{octeto}</span>;\r\n                }\r\n                // Si el octeto está completamente en la porción de host\r\n                else {\r\n                    return <span key={index} className=\"host-portion\">{octeto}</span>;\r\n                }\r\n            })\r\n        };\r\n    }\r\n\r\n    function calcular() {\r\n        let partesIP = inputIP.split(\".\");\r\n        let partesMascara = inputMascara.split(\".\");\r\n\r\n        // Validar que cada octeto esté en el rango correcto\r\n        for (let i = 0; i < partesIP.length; i++) {\r\n            const octeto = parseInt(partesIP[i]);\r\n            \r\n            // Verificar que sea un número válido y esté en el rango 0-255\r\n            if (isNaN(octeto) || octeto < 0 || octeto > 255) {\r\n                alert(`El octeto ${i + 1} de la IP no es válido. Debe ser un número entre 0 y 255.`);\r\n                return;\r\n            }\r\n\r\n            // Verificar que no haya números con ceros a la izquierda (excepto el 0)\r\n            if (partesIP[i].length > 1 && partesIP[i][0] === '0') {\r\n                alert(`El octeto ${i + 1} de la IP no puede tener ceros a la izquierda.`);\r\n                return;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < partesMascara.length; i++) {\r\n            const octeto = parseInt(partesMascara[i]);\r\n            \r\n            // Verificar que sea un número válido y esté en el rango 0-255\r\n            if (isNaN(octeto) || octeto < 0 || octeto > 255) {\r\n                alert(`El octeto ${i + 1} de la máscara no es válido. Debe ser un número entre 0 y 255.`);\r\n                return;\r\n            }\r\n\r\n            // Verificar que no haya números con ceros a la izquierda (excepto el 0)\r\n            if (partesMascara[i].length > 1 && partesMascara[i][0] === '0') {\r\n                alert(`El octeto ${i + 1} de la máscara no puede tener ceros a la izquierda.`);\r\n                return;\r\n            }\r\n        }\r\n        \r\n        console.log(\"La dirección IP y la máscara son válidas\");\r\n\r\n        const ipBinario = convertirOctetosABinario(partesIP);\r\n        const mascaraBinario = convertirOctetosABinario(partesMascara);\r\n\r\n        // Realizar operaciones AND y OR a nivel de bits\r\n        let redBinaria = '';\r\n        let broadcastBinaria = '';\r\n        \r\n        for(let i = 0; i < 32; i++) {\r\n            // Calcular dirección de red (AND)\r\n            redBinaria += (ipBinario[i] === '1' && mascaraBinario[i] === '1') ? '1' : '0';\r\n            \r\n            // Calcular broadcast (OR con NOT máscara)\r\n            broadcastBinaria += (mascaraBinario[i] === '1') ? redBinaria[i] : '1';\r\n        }\r\n\r\n        // Convertir resultados a formato decimal\r\n        const ipRed = convertirBinarioADecimal(redBinaria);\r\n        const ipBroadcast = convertirBinarioADecimal(broadcastBinaria);\r\n\r\n        // Calcular primera y última IP útil\r\n        const primeraIPBinaria = redBinaria.slice(0, -1) + '1';\r\n        const ultimaIPBinaria = broadcastBinaria.slice(0, -1) + '0';\r\n\r\n        const primeraIP = convertirBinarioADecimal(primeraIPBinaria);\r\n        const ultimaIP = convertirBinarioADecimal(ultimaIPBinaria);\r\n\r\n        // Calcular hosts (utilizando la máscara)\r\n        const unosEnMascara = mascaraBinario.split('1').length - 1;\r\n        const hosts = Math.pow(2, 32 - unosEnMascara) - 2;\r\n\r\n        const representacionBinaria = visualizarRedBinaria(ipBinario, mascaraBinario);\r\n        \r\n        setResultado({\r\n            ipRed,\r\n            ipBroadcast,\r\n            hosts,\r\n            rangoUtil: `${primeraIP} - ${ultimaIP}`,\r\n            clase: obtenerClaseIP(parseInt(partesIP[0])),\r\n            esPrivada: esIPPrivada(inputIP),\r\n            representacionBinaria: representacionBinaria\r\n        });\r\n    }\r\n\r\n    function limpiar() {\r\n        setInputIP(\"\");\r\n        setInputMascara(\"\");\r\n        setResultado(null);\r\n    }\r\n\r\n    return (\r\n        <div className=\"calculadora\">\r\n            <h1 className=\"titulo-principal\">Calculadora de Direcciones IP</h1>\r\n            <div className=\"input-group\">\r\n                <InputIP value={inputIP} onChange={setInputIP} />\r\n                <InputMascara value={inputMascara} onChange={setInputMascara} />\r\n                <button onClick={calcular}>Calcular</button>\r\n                <button onClick={limpiar} style={{marginLeft: '10px'}}>Limpiar</button>\r\n            </div>\r\n            <ResultadosIP resultado={resultado} />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Calculadora;"],"mappings":";;AACA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAO,cAAc;AACrB,OAAOC,OAAO,MAAM,WAAW;AAC/B,OAAOC,YAAY,MAAM,gBAAgB;AACzC,OAAOC,YAAY,MAAM,gBAAgB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE1C,SAASC,WAAWA,CAAA,EAAG;EAAAC,EAAA;EACnB,IAAI,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAGT,KAAK,CAACU,QAAQ,CAAC,EAAE,CAAC;EAC9C,IAAI,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGZ,KAAK,CAACU,QAAQ,CAAC,EAAE,CAAC;EACxD,IAAI,CAACG,SAAS,EAAEC,YAAY,CAAC,GAAGd,KAAK,CAACU,QAAQ,CAAC,IAAI,CAAC;;EAEpD;;EAEA,SAASK,cAAcA,CAACC,YAAY,EAAE;IAClC,IAAIA,YAAY,IAAI,CAAC,IAAIA,YAAY,IAAI,GAAG,EAAE,OAAO,GAAG;IACxD,IAAIA,YAAY,IAAI,GAAG,IAAIA,YAAY,IAAI,GAAG,EAAE,OAAO,GAAG;IAC1D,IAAIA,YAAY,IAAI,GAAG,IAAIA,YAAY,IAAI,GAAG,EAAE,OAAO,GAAG;IAC1D,IAAIA,YAAY,IAAI,GAAG,IAAIA,YAAY,IAAI,GAAG,EAAE,OAAO,GAAG;IAC1D,IAAIA,YAAY,IAAI,GAAG,IAAIA,YAAY,IAAI,GAAG,EAAE,OAAO,GAAG;IAC1D,OAAO,WAAW;EACtB;EAEA,SAASC,wBAAwBA,CAACC,OAAO,EAAE;IACvC;IACA,IAAIC,QAAQ,GAAGD,OAAO,CAACE,GAAG,CAACC,MAAM,IAAI;MACjC;MACA,IAAIC,GAAG,GAAGC,QAAQ,CAACF,MAAM,CAAC,CAACG,QAAQ,CAAC,CAAC,CAAC;MACtC;MACA,OAAOF,GAAG,CAACG,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;IAC/B,CAAC,CAAC;;IAEF;IACA,OAAON,QAAQ,CAACO,IAAI,CAAC,EAAE,CAAC;EAC5B;EAEA,SAASC,wBAAwBA,CAACC,OAAO,EAAE;IACvC,MAAMV,OAAO,GAAG,EAAE;IAClB;IACA,KAAI,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,IAAI,CAAC,EAAE;MAC3B,MAAMR,MAAM,GAAGE,QAAQ,CAACK,OAAO,CAACE,MAAM,CAACD,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAChDX,OAAO,CAACa,IAAI,CAACV,MAAM,CAAC;IACxB;IACA,OAAOH,OAAO,CAACQ,IAAI,CAAC,GAAG,CAAC;EAC5B;EAEA,SAASM,WAAWA,CAACC,EAAE,EAAE;IACrB,MAAMf,OAAO,GAAGe,EAAE,CAACC,KAAK,CAAC,GAAG,CAAC;IAC7B,IAAIhB,OAAO,CAACiB,MAAM,KAAK,CAAC,EAAE,OAAO,KAAK;IAEtC,MAAMnB,YAAY,GAAGO,QAAQ,CAACL,OAAO,CAAC,CAAC,CAAC,CAAC;IACzC,MAAMkB,aAAa,GAAGb,QAAQ,CAACL,OAAO,CAAC,CAAC,CAAC,CAAC;;IAE1C;IACA,IAAIF,YAAY,KAAK,EAAE,EAAE;MACrB,OAAO,IAAI;IACf;;IAEA;IACA,IAAIA,YAAY,KAAK,GAAG,IACpBoB,aAAa,IAAI,EAAE,IACnBA,aAAa,IAAI,EAAE,EAAE;MACrB,OAAO,IAAI;IACf;;IAEA;IACA,IAAIpB,YAAY,KAAK,GAAG,IACpBoB,aAAa,KAAK,GAAG,EAAE;MACvB,OAAO,IAAI;IACf;;IAEA;IACA,IAAIpB,YAAY,KAAK,GAAG,IACpBoB,aAAa,KAAK,GAAG,EAAE;MACvB,OAAO,IAAI;IACf;;IAEA;IACA,IAAIpB,YAAY,KAAK,GAAG,EAAE;MACtB,OAAO,IAAI;IACf;IAEA,OAAO,KAAK;EAChB;EAEA,SAASqB,oBAAoBA,CAACC,SAAS,EAAEC,cAAc,EAAE;IACrD,MAAMN,EAAE,GAAGK,SAAS,CAACE,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;IACjC,MAAMC,OAAO,GAAGF,cAAc,CAACC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;IAE3C,MAAMtB,OAAO,GAAGe,EAAE,CAACS,KAAK,CAAC,OAAO,CAAC;;IAEjC;IACA,MAAMC,YAAY,GAAGF,OAAO,CAACG,OAAO,CAAC,GAAG,CAAC;IAEzC,OAAO;MACHC,UAAU,EAAE3B,OAAO,CAACE,GAAG,CAAC,CAACC,MAAM,EAAEyB,KAAK,KAAK;QACvC;QACA,MAAMC,UAAU,GAAGD,KAAK,GAAG,CAAC;QAC5B,MAAME,QAAQ,GAAGD,UAAU,GAAG,CAAC;;QAE/B;QACA,IAAIJ,YAAY,IAAII,UAAU,IAAIJ,YAAY,GAAGK,QAAQ,EAAE;UACvD,MAAMC,QAAQ,GAAGN,YAAY,GAAG,CAAC;UACjC,oBACItC,OAAA;YAAA6C,QAAA,gBACI7C,OAAA;cAAM8C,SAAS,EAAC,aAAa;cAAAD,QAAA,EAAE7B,MAAM,CAAC+B,SAAS,CAAC,CAAC,EAAEH,QAAQ;YAAC;cAAAI,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAO,CAAC,eACpEnD,OAAA;cAAM8C,SAAS,EAAC,cAAc;cAAAD,QAAA,EAAE7B,MAAM,CAAC+B,SAAS,CAACH,QAAQ;YAAC;cAAAI,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAO,CAAC;UAAA,GAF3DV,KAAK;YAAAO,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAGV,CAAC;QAEf;QACA;QAAA,KACK,IAAIT,UAAU,GAAGJ,YAAY,EAAE;UAChC,oBAAOtC,OAAA;YAAkB8C,SAAS,EAAC,aAAa;YAAAD,QAAA,EAAE7B;UAAM,GAAtCyB,KAAK;YAAAO,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAwC,CAAC;QACpE;QACA;QAAA,KACK;UACD,oBAAOnD,OAAA;YAAkB8C,SAAS,EAAC,cAAc;YAAAD,QAAA,EAAE7B;UAAM,GAAvCyB,KAAK;YAAAO,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAyC,CAAC;QACrE;MACJ,CAAC;IACL,CAAC;EACL;EAEA,SAASC,QAAQA,CAAA,EAAG;IAChB,IAAIC,QAAQ,GAAGlD,OAAO,CAAC0B,KAAK,CAAC,GAAG,CAAC;IACjC,IAAIyB,aAAa,GAAGhD,YAAY,CAACuB,KAAK,CAAC,GAAG,CAAC;;IAE3C;IACA,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6B,QAAQ,CAACvB,MAAM,EAAEN,CAAC,EAAE,EAAE;MACtC,MAAMR,MAAM,GAAGE,QAAQ,CAACmC,QAAQ,CAAC7B,CAAC,CAAC,CAAC;;MAEpC;MACA,IAAI+B,KAAK,CAACvC,MAAM,CAAC,IAAIA,MAAM,GAAG,CAAC,IAAIA,MAAM,GAAG,GAAG,EAAE;QAC7CwC,KAAK,CAAC,aAAahC,CAAC,GAAG,CAAC,2DAA2D,CAAC;QACpF;MACJ;;MAEA;MACA,IAAI6B,QAAQ,CAAC7B,CAAC,CAAC,CAACM,MAAM,GAAG,CAAC,IAAIuB,QAAQ,CAAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAClDgC,KAAK,CAAC,aAAahC,CAAC,GAAG,CAAC,gDAAgD,CAAC;QACzE;MACJ;IACJ;IAEA,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8B,aAAa,CAACxB,MAAM,EAAEN,CAAC,EAAE,EAAE;MAC3C,MAAMR,MAAM,GAAGE,QAAQ,CAACoC,aAAa,CAAC9B,CAAC,CAAC,CAAC;;MAEzC;MACA,IAAI+B,KAAK,CAACvC,MAAM,CAAC,IAAIA,MAAM,GAAG,CAAC,IAAIA,MAAM,GAAG,GAAG,EAAE;QAC7CwC,KAAK,CAAC,aAAahC,CAAC,GAAG,CAAC,gEAAgE,CAAC;QACzF;MACJ;;MAEA;MACA,IAAI8B,aAAa,CAAC9B,CAAC,CAAC,CAACM,MAAM,GAAG,CAAC,IAAIwB,aAAa,CAAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC5DgC,KAAK,CAAC,aAAahC,CAAC,GAAG,CAAC,qDAAqD,CAAC;QAC9E;MACJ;IACJ;IAEAiC,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;IAEvD,MAAMzB,SAAS,GAAGrB,wBAAwB,CAACyC,QAAQ,CAAC;IACpD,MAAMM,cAAc,GAAG/C,wBAAwB,CAAC0C,aAAa,CAAC;;IAE9D;IACA,IAAIM,UAAU,GAAG,EAAE;IACnB,IAAIC,gBAAgB,GAAG,EAAE;IAEzB,KAAI,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;MACxB;MACAoC,UAAU,IAAK3B,SAAS,CAACT,CAAC,CAAC,KAAK,GAAG,IAAImC,cAAc,CAACnC,CAAC,CAAC,KAAK,GAAG,GAAI,GAAG,GAAG,GAAG;;MAE7E;MACAqC,gBAAgB,IAAKF,cAAc,CAACnC,CAAC,CAAC,KAAK,GAAG,GAAIoC,UAAU,CAACpC,CAAC,CAAC,GAAG,GAAG;IACzE;;IAEA;IACA,MAAMsC,KAAK,GAAGxC,wBAAwB,CAACsC,UAAU,CAAC;IAClD,MAAMG,WAAW,GAAGzC,wBAAwB,CAACuC,gBAAgB,CAAC;;IAE9D;IACA,MAAMG,gBAAgB,GAAGJ,UAAU,CAACzB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,GAAG;IACtD,MAAM8B,eAAe,GAAGJ,gBAAgB,CAAC1B,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,GAAG;IAE3D,MAAM+B,SAAS,GAAG5C,wBAAwB,CAAC0C,gBAAgB,CAAC;IAC5D,MAAMG,QAAQ,GAAG7C,wBAAwB,CAAC2C,eAAe,CAAC;;IAE1D;IACA,MAAMG,aAAa,GAAGT,cAAc,CAAC9B,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,GAAG,CAAC;IAC1D,MAAMuC,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,GAAGH,aAAa,CAAC,GAAG,CAAC;IAEjD,MAAMI,qBAAqB,GAAGxC,oBAAoB,CAACC,SAAS,EAAE0B,cAAc,CAAC;IAE7ElD,YAAY,CAAC;MACTqD,KAAK;MACLC,WAAW;MACXM,KAAK;MACLI,SAAS,EAAE,GAAGP,SAAS,MAAMC,QAAQ,EAAE;MACvCO,KAAK,EAAEhE,cAAc,CAACQ,QAAQ,CAACmC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;MAC5CsB,SAAS,EAAEhD,WAAW,CAACxB,OAAO,CAAC;MAC/BqE,qBAAqB,EAAEA;IAC3B,CAAC,CAAC;EACN;EAEA,SAASI,OAAOA,CAAA,EAAG;IACfxE,UAAU,CAAC,EAAE,CAAC;IACdG,eAAe,CAAC,EAAE,CAAC;IACnBE,YAAY,CAAC,IAAI,CAAC;EACtB;EAEA,oBACIT,OAAA;IAAK8C,SAAS,EAAC,aAAa;IAAAD,QAAA,gBACxB7C,OAAA;MAAI8C,SAAS,EAAC,kBAAkB;MAAAD,QAAA,EAAC;IAA6B;MAAAG,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI,CAAC,eACnEnD,OAAA;MAAK8C,SAAS,EAAC,aAAa;MAAAD,QAAA,gBACxB7C,OAAA,CAACJ,OAAO;QAACiF,KAAK,EAAE1E,OAAQ;QAAC2E,QAAQ,EAAE1E;MAAW;QAAA4C,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC,eACjDnD,OAAA,CAACH,YAAY;QAACgF,KAAK,EAAEvE,YAAa;QAACwE,QAAQ,EAAEvE;MAAgB;QAAAyC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC,eAChEnD,OAAA;QAAQ+E,OAAO,EAAE3B,QAAS;QAAAP,QAAA,EAAC;MAAQ;QAAAG,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC,eAC5CnD,OAAA;QAAQ+E,OAAO,EAAEH,OAAQ;QAACI,KAAK,EAAE;UAACC,UAAU,EAAE;QAAM,CAAE;QAAApC,QAAA,EAAC;MAAO;QAAAG,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACtE,CAAC,eACNnD,OAAA,CAACF,YAAY;MAACU,SAAS,EAAEA;IAAU;MAAAwC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACrC,CAAC;AAEd;AAACjD,EAAA,CAvNQD,WAAW;AAAAiF,EAAA,GAAXjF,WAAW;AAyNpB,eAAeA,WAAW;AAAC,IAAAiF,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}